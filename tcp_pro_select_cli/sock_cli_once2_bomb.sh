
tmp=10
:()
{
#炸弹控制部分
if test "$tmp" = "0";then
	exit # 等于0 就退出了
fi
let tmp=tmp-1 # 不等于0, tmp - 1
echo $tmp
#执行炸弹部分递归
:|: & # 管道不影响shell 脚本调用的次数, 只是并发数量不足而已.
####### 最好: 有8个线程的4 核CPU 运行10 个shell 左右就开始饱和了.
####### 系统文件句柄, 要改多一点: ulimit -n 40960 (需要root 权限)
####### 递归: tmp=1, shell_test_count = 10, test_count = 10
####### 递归: tmp=2, shell_test_count = 10, test_count = 32
####### 递归: tmp=3, shell_test_count = 10, test_count = 76
####### 递归: tmp=4, shell_test_count = 10, test_count = 164
####### 递归: tmp=5, shell_test_count = 10, test_count = 340
####### 递归: tmp=10, shell_test_count = 10, test_count = 6301
####### 递归: tmp=10, shell_test_count = 20, test_count = 10706
#######       数据太多, 很多recv() 错误, 已经不准确了...
####### 递归: tmp=10, shell_test_count = 20, test_count = 17028
#######       用select 异步版本基本一个都没有错, 就是17028 这个数字
#######       
####### 架构2 写得更严谨, 效率却更低的原因:
####### 捆死在waitpid() 的事情上面, 一对一的自己消除孙进程信息, 是个错误!
####### 为什么这么说?: 因为僵尸进程的问题又回来了...10706 这个数字
####### 为什么会有僵尸进程？？ 不是销毁了吗？
####### 原因很简单!! waitpid() 那个循环里面, deque + waitpid 异步, 太慢了
####### 客户端的发送/接收超时是1 秒, 加大这个时间或许情况会好一点
####### 但是效率还是很低, 但是跑到了19417 次??
####### 准确率可能会高一点, 因为你知道孙进程的退出状态...
####### 
####### 最好的方式还是, 孙进程在退出的时候, 用信号量+共享内存的方式, 通知父进程
####### 这样才是最高效率的, 也不会出现: 客户端都关闭了, 服务器才发数据下去
####### 这样延迟太厉害了, 3 秒都没发数据下去哦！！
./sock_cli_once2.sh
};
:
